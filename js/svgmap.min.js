/*!
 *
 *    kartograph - a svg mapping library 
 *    Copyright (C) 2011  Gregor Aisch
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * 
 */(function(){var a,b,c,d,e,f,g,h,i,j,k,l,n,o,p,q,r,t,u,v,w,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC=Object.prototype.hasOwnProperty,bD=function(a,b){function d(){this.constructor=a}for(var c in b)bC.call(b,c)&&(a[c]=b[c]);d.prototype=b.prototype,a.prototype=new d,a.__super__=b.prototype;return a},bE=function(a,b){return function(){return a.apply(b,arguments)}};bk=typeof exports!="undefined"&&exports!==null?exports:this,bi=(bo=bk.kartograph)!=null?bo:bk.kartograph={},c=function(){function a(a,b,c,d){var e;a==null&&(a=0),b==null&&(b=0),c==null&&(c=null),d==null&&(d=null),e=this,c===null?(e.xmin=Number.MAX_VALUE,e.xmax=Number.MAX_VALUE*-1):(e.xmin=e.left=a,e.xmax=e.right=a+c,e.width=c),d===null?(e.ymin=Number.MAX_VALUE,e.ymax=Number.MAX_VALUE*-1):(e.ymin=e.top=b,e.ymax=e.bottom=d+b,e.height=d);return}a.prototype.update=function(a,b){var c;b==null&&(b=a[1],a=a[0]),c=this,c.xmin=Math.min(c.xmin,a),c.ymin=Math.min(c.ymin,b),c.xmax=Math.max(c.xmax,a),c.ymax=Math.max(c.ymax,b),c.left=c.xmin,c.top=c.ymin,c.right=c.xmax,c.bottom=c.ymax,c.width=c.xmax-c.xmin,c.height=c.ymax-c.ymin;return this},a.prototype.intersects=function(a){return a.left<s.right&&a.right>s.left&&a.top<s.bottom&&a.bottom>s.top},a.prototype.inside=function(a,b){var c;c=this;return a>=c.left&&a<=c.right&&b>=c.top&&b<=c.bottom},a.prototype.join=function(a){var b;b=this,b.update(a.left,a.top),b.update(a.right,a.bottom);return this};return a}(),c.fromXML=function(a){var b,c,d,e;d=Number(a.getAttribute("x")),e=Number(a.getAttribute("y")),c=Number(a.getAttribute("w")),b=Number(a.getAttribute("h"));return new bi.BBox(d,e,c,b)},bi.BBox=c,"kartograph - a svg mapping library \nCopyright (C) 2011  Gregor Aisch\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.",bk=typeof exports!="undefined"&&exports!==null?exports:this,bi=(bu=bk.kartograph)!=null?bu:bk.kartograph={},(bv=bi.geom)==null&&(bi.geom={}),(bw=(bn=bi.geom).clipping)==null&&(bn.clipping={}),l=function(){function f(){}var a,b,c,d,e;b=0,c=1,d=2,a=4,e=8,f.prototype.compute_out_code=function(a,b,c){var d,e;e=this,d=e.INSIDE,b<a.left?d|=e.LEFT:b>a.right&&(d|=e.RIGHT),c<a.top?d|=e.TOP:c>a.bottom&&(d|=e.BOTTOM);return d},f.prototype.clip=function(a,b,c,d,e){var f,g,h,i,j,k,l;j=this,g=j.compute_out_code(a,b,c),h=j.compute_out_code(a,d,e),f=False;while(True){if(!(g|h)){f=True;break}if(g&h)break;i=code===0?h:g,i&j.TOP?(k=b+(d-b)*(a.top-c)/(e-c),l=a.top):i&j.BOTTOM?(k=b+(d-b)*(a.bottom-c)/(e-c),l=a.bottom):i&j.RIGHT?(l=c+(e-c)*(a.right-b)/(d-b),k=a.right):i&j.LEFT&&(l=c+(e-c)*(a.left-b)/(d-b),k=a.left),i===g?(b=k,c=l,g=j.compute_out_code(a,b,c)):(d=k,e=l,h=j.compute_out_code(a,d,e))}return f?[b,c,d,e]:null};return f}(),bi.geom.clipping.CohenSutherland=l,bk=typeof exports!="undefined"&&exports!==null?exports:this,bi=(bx=bk.kartograph)!=null?bx:bk.kartograph={},bh=(by=bi.filter)!=null?by:bi.filter={},u=function(){function a(a){this.params=a!=null?a:{}}a.prototype.getFilter=function(a){var b,c;c=this,b=c.SVG("filter",{id:a}),c.buildFilter(b);return b},a.prototype._getFilter=function(){throw"not implemented"},a.prototype.SVG=function(a,b){var c,d;typeof a=="string"&&(a=window.document.createElementNS("http://www.w3.org/2000/svg",a));if(b)for(c in b)d=b[c],a.setAttribute(c,d);return a};return a}(),f=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,u),a.prototype.buildFilter=function(a){var b,c,d;d=this,b=d.SVG,c=b("feGaussianBlur",{stdDeviation:d.params.size||4,result:"blur"});return a.appendChild(c)};return a}(),bh.blur=f,w=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,u),a.prototype.buildFilter=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o;g=this,c=(m=g.params.blur)!=null?m:4,i=(n=g.params.strength)!=null?n:1,d=(o=g.params.color)!=null?o:"#D1BEB0",typeof d=="string"&&(d=chroma.hex(d)),h=d.rgb,e=(j=g.params.inner)!=null?j:!1,f=(k=g.params.knockout)!=null?k:!1,b=(l=g.params.alpha)!=null?l:1,e?g.innerGlow(a,c,i,h,b,f):g.outerGlow(a,c,i,h,b,f)},a.prototype.outerGlow=function(a,b,c,d,e,f){var g,h,i,j,k,l,m;k=this,g=k.SVG,j=g("feColorMatrix",{"in":"SourceGraphic",type:"matrix",values:"0 0 0 0 0   0 0 0 0 0   0 0 0 0 0   0 0 0 1 0",result:"mask"}),a.appendChild(j),c>0&&(m=g("feMorphology",{"in":"mask",radius:c,operator:"dilate",result:"mask"}),a.appendChild(m)),j=g("feColorMatrix",{"in":"mask",type:"matrix",values:"0 0 0 0 "+d[0]/255+" 0 0 0 0 "+d[1]/255+" 0 0 0 0 "+d[2]/255+"  0 0 0 1 0",result:"r0"}),a.appendChild(j),h=g("feGaussianBlur",{"in":"r0",stdDeviation:b,result:"r1"}),a.appendChild(h),i=g("feComposite",{operator:"out","in":"r1",in2:"mask",result:"comp"}),a.appendChild(i),l=g("feMerge"),f||l.appendChild(g("feMergeNode",{"in":"SourceGraphic"})),l.appendChild(g("feMergeNode",{"in":"r1"}));return a.appendChild(l)},a.prototype.innerGlow=function(a,b,c,d,e,f){var g,h,i,j,k,l,m;k=this,g=k.SVG,console.log("innerglow"),j=g("feColorMatrix",{"in":"SourceGraphic",type:"matrix",values:"0 0 0 0 0   0 0 0 0 0   0 0 0 0 0   0 0 0 500 0",result:"mask"}),a.appendChild(j),m=g("feMorphology",{"in":"mask",radius:c,operator:"erode",result:"r1"}),a.appendChild(m),h=g("feGaussianBlur",{"in":"r1",stdDeviation:b,result:"r2"}),a.appendChild(h),j=g("feColorMatrix",{type:"matrix","in":"r2",values:"1 0 0 0 "+d[0]/255+" 0 1 0 0 "+d[1]/255+" 0 0 1 0 "+d[2]/255+" 0 0 0 -1 "+e,result:"r3"}),a.appendChild(j),i=g("feComposite",{operator:"in","in":"r3",in2:"mask",result:"comp"}),a.appendChild(i),l=g("feMerge"),f||l.appendChild(g("feMergeNode",{"in":"SourceGraphic"})),l.appendChild(g("feMergeNode",{"in":"comp"}));return a.appendChild(l)};return a}(),bh.glow=w,bk=typeof exports!="undefined"&&exports!==null?exports:this,bi=bk.K=(bz=bk.kartograph)!=null?bz:bk.kartograph={},bi.version="0.4.2",bl=function(a){return console.warn("kartograph ("+bi.version+"): "+a)},bj=function(a){return console.log("kartograph ("+bi.version+"): "+a)},D=function(){function a(a){var b,c;c=this,c.container=b=$(a),c.viewport=new bi.BBox(0,0,b.width(),b.height()),c.paper=c.createSVGLayer(),c.markers=[],c.container.addClass("kartograph")}a.prototype.createSVGLayer=function(a){var b,c,d,e,f,g,h,i;e=this,(i=e._layerCnt)==null&&(e._layerCnt=0),d=e._layerCnt++,h=e.viewport,c=e.container,f=Raphael(c[0],h.width,h.height),g=$(f.canvas),g.css({position:"absolute",top:"0px",left:"0px","z-index":d+5}),c.css("position")==="static"&&c.css("position","relative"),g.addClass(a),b=$("desc",f.canvas).text(),$("desc",f.canvas).text(b.replace("with ","with kartograph "+bi.version+" and "));return f},a.prototype.createHTMLLayer=function(a){var b,c,d,e,f,g;e=this,f=e.viewport,b=e.container,(g=e._layerCnt)==null&&(e._layerCnt=0),d=e._layerCnt++,c=$('<div class="layer '+a+'" />'),c.css({position:"absolute",top:"0px",left:"0px",width:f.width+"px",height:f.height+"px","z-index":d+5}),b.append(c);return c},a.prototype.loadMap=function(a,b,c){var d,e,f;d=this,d.opts=c!=null?c:{},(f=(e=d.opts).zoom)==null&&(e.zoom=1),d.mapLoadCallback=b,$.ajax({url:a,success:d.mapLoaded,context:d})},a.prototype.addLayer=function(a,b,c){var d,e,f,g,h,i,j,k,l;f=this,(k=f.layerIds)==null&&(f.layerIds=[]),(l=f.layers)==null&&(f.layers={}),b==null&&(b=a),g=$("g#"+a,f.svgSrc);if(g.length===0)bl("didn't find any paths for layer \""+b+'"');else{e=new M(b,c,f.paper,f.viewBC),d=$("*",g[0]);for(i=0,j=d.length;i<j;i++)h=d[i],e.addPath(h);e.paths.length>0?(f.layers[b]=e,f.layerIds.push(b)):bl("didn't find any paths for layer "+b)}},a.prototype.getLayerPath=function(a,b){var c;c=this;return c.layers[a]!=null&&c.layers[a].hasPath(b)?c.layers[a].getPath(b):null},a.prototype.addCanvasLayer=function(a,b){var c,d,e,f,g,h,i,k;f=this,f.canvas==null&&(d=$("<canvas />"),d.css({position:"absolute",top:"0px",left:"0px"}),d.attr({width:f.viewport.width+"px",height:f.viewport.height+"px"}),f.container.append(d),f.canvas=d[0]),g=$("g#"+a,f.svgSrc);if(g.length===0)bl("didn't find any paths for layer \""+layer_id+'"');else{e=new j(a,f.canvas,f.viewBC,b),c=$("*",g[0]);for(i=0,k=c.length;i<k;i++)h=c[i],e.addPath(h);return e.render()}},a.prototype.addLayerEvent=function(a,b,c){var d,e,f,g,h,i;d=this,c==null&&(c=d.layerIds[d.layerIds.length-1]),f=d.layers[c].paths,i=[];for(g=0,h=f.length;g<h;g++)e=f[g],i.push($(e.svgPath.node).bind(a,b));return i},a.prototype.addMarker=function(a){var b,c;b=this,b.markers.push(a),c=b.viewBC.project(b.viewAB.project(b.proj.project(a.lonlat.lon,a.lonlat.lat)));return a.render(c[0],c[1],b.container,b.paper)},a.prototype.clearMarkers=function(){var a,b,c,d,e;b=this,e=b.markers;for(c=0,d=e.length;c<d;c++)a=e[c],a.clear();return b.markers=[]},a.prototype.choropleth=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s;h=this,g=(r=a.layer)!=null?r:h.layerIds[h.layerIds.length-1];if(!h.layers.hasOwnProperty(g))bl('choropleth error: layer "'+layer_ihad+'" not found');else{d=a.data,e=a.key,i=(s=a.noDataColor)!=null?s:"#ccc",c=a.colorscale,k={};for(f in d)m=d[f],k[f]=m[e];q=h.layers[g].pathsById;for(f in q){l=q[f];for(o=0,p=l.length;o<p;o++)j=l[o],k[f]!=null&&c.validValue(k[f])?(n=k[f],b=c.getColor(n),j.svgPath.node.setAttribute("style","fill:"+b)):j.svgPath.node.setAttribute("style","fill:"+i)}}},a.prototype.tooltips=function(a){var b,c,d,e,f,g,h,i,j,k,l;e=this,h=a.content,d=(j=a.layer)!=null?j:e.layerIds[e.layerIds.length-1];if(!e.layers.hasOwnProperty(d))bl('tooltips error: layer "'+d+'" not found');else{k=e.layers[d].pathsById,l=[];for(c in k)g=k[c],l.push(function(){var a,d,e;e=[];for(a=0,d=g.length;a<d;a++)f=g[a],$.isFunction(h)?i=h(c,f):i=h[c],i!=null?(b={position:{target:"mouse",viewport:$(window),adjust:{x:7,y:7}},show:{delay:20},content:{}},typeof i=="string"?b.content.text=i:$.isArray(i)&&(b.content.title=i[0],b.content.text=i[1]),e.push($(f.svgPath.node).qtip(b))):e.push(void 0);return e}());return l}},a.prototype.display=function(){return this.render()},a.prototype.mapLoaded=function(a){var b,c,d,e,f,g,h,i,j,k;e=this,e.svgSrc=a,h=e.viewport,b=$("view",a)[0],e.viewAB=c=bi.View.fromXML(b),f=(j=e.opts.padding)!=null?j:0,d=(k=e.opts.halign)!=null?k:"center",g=(i=e.opts.valign)!=null?i:"center",e.viewBC=new bi.View(c.asBBox(),h.width,h.height,f,d,g),e.proj=bi.Proj.fromXML($("proj",b)[0]);return e.mapLoadCallback(e)},a.prototype.loadCoastline=function(){var a;a=this;return $.ajax({url:"coastline.json",success:a.renderCoastline,context:a})},a.prototype.renderCoastline=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p;f=this,b=f.proj,l=f.viewport,j=f.viewAB,k=f.viewBC,p=[];for(m=0,n=a.length;m<n;m++){e=a[m],i="";for(d=0,o=e.length-2;0<=o?d<=o:d>=o;0<=o?d++:d--){g=e[d],h=e[d+1],c=0;if(b._visible(g[0],g[1])&&b._visible(h[0],h[1])){g=k.project(j.project(b.project(g[0],g[1]))),h=k.project(j.project(b.project(h[0],h[1])));if(l.inside(g[0],g[1])||l.inside(h[0],h[1]))i+="M"+g[0]+","+g[1]+"L"+h[0]+","+h[1]}}i!==""?p.push(f.paper.path(i).attr("opacity",.8)):p.push(void 0)}return p},a.prototype.onPathEvent=function(a){var b,c;b=this,c=a.target.path;return b.layerEventCallbacks[c.layer][a.type](c)},a.prototype.resize=function(){var a,b,c,d,e,f,g,h,i,j,k,l,m,n;e=this,a=e.container,e.viewport=h=new bi.BBox(0,0,a.width(),a.height()),e.paper.setSize(h.width,h.height),h=e.viewport,f=(l=e.opts.padding)!=null?l:0,b=(m=e.opts.halign)!=null?m:"center",g=(j=e.opts.valign)!=null?j:"center",i=e.opts.zoom,e.viewBC=new bi.View(e.viewAB.asBBox(),h.width*i,h.height*i,f,b,g),k=e.layers,n=[];for(c in k)d=k[c],n.push(d.setView(e.viewBC));return n},a.prototype.addFilter=function(a,b,c){var d,e,f;c==null&&(c={}),f=this,d=window.document;if(bi.filter[b]!=null)e=(new bi.filter[b](c)).getFilter(a);else throw"unknown filter type "+b;return f.paper.defs.appendChild(e)},a.prototype.applyFilter=function(a,b){var c;c=this;return $(".polygon."+a,c.paper.canvas).attr({filter:"url(#"+b+")"})},a.prototype.lonlat2xy=function(a){var b,c;c=this,a.length===2&&(a=new bi.LonLat(a[0],a[1])),a.length===3&&(a=new bi.LonLat(a[0],a[1],a[2])),b=c.proj.project(a.lon,a.lat,a.alt);return c.viewBC.project(c.viewAB.project(b))},a.prototype.addGeoPath=function(a,b,c){var d,e,f,g,h,i,j,k;b==null&&(b=[]),c==null&&(c=""),f=this,b.length===0&&b.push("M"),h="";for(e in a)i=a[e],d=(k=b[e])!=null?k:"L",j=f.lonlat2xy(i),h+=d+j[0]+","+j[1];g=f.paper.path(h),g.node.setAttribute("class",c)},a.prototype.showZoomControls=function(){var a;a=this,a.zc=new T(a);return a};return a}(),bi.Kartograph=D,M=function(){function a(a,b,c,d){var e;e=this,e.id=a,e.path_id=b,e.paper=c,e.view=d}a.prototype.addPath=function(a){var b,c,d,e,f,g,h;c=this,(g=c.paths)==null&&(c.paths=[]),b=new N(a,c.id,c.paper,c.view),c.paths.push(b);if(c.path_id!=null){(h=c.pathsById)==null&&(c.pathsById={}),(f=(d=c.pathsById)[e=b.data[c.path_id]])==null&&(d[e]=[]);return c.pathsById[b.data[c.path_id]].push(b)}},a.prototype.hasPath=function(a){var b;b=this;return b.pathsById!=null&&b.pathsById[a]!=null},a.prototype.getPath=function(a){var b;b=this;if(b.hasPath(a))return b.pathsById[a][0];throw"path "+a+" not found"},a.prototype.setView=function(a){var b,c,d,e,f,g;b=this,f=b.paths,g=[];for(d=0,e=f.length;d<e;d++)c=f[d],g.push(c.setView(a));return g};return a}(),N=function(){function a(a,b,c,d){var e,f,g,h,i,j;h=this,h.path=i=bi.geom.Path.fromSVG(a),h.svgPath=d.projectPath(i).toSVG(c),h.baseClass="polygon "+b,h.svgPath.node.setAttribute("class",h.baseClass),h.svgPath.node.path=h,f={};for(g=0,j=a.attributes.length-1;0<=j?g<=j:g>=j;0<=j?g++:g--)e=a.attributes[g],e.name.substr(0,5)==="data-"&&(f[e.name.substr(5)]=e.value);h.data=f}a.prototype.setView=function(a){var b,c,d;b=this,c=a.projectPath(b.path);if(b.path.type==="path"){d=c.svgString();return b.svgPath.attr({path:d})}if(b.path.type==="circle")return b.svgPath.attr({cx:c.x,cy:c.y,r:c.r})};return a}(),j=function(){function a(a,b,c,d){var e;e=this,e.layer_id=a,e.canvas=b,e.view=c,e.renderCallback=d}a.prototype.addPath=function(a){var b,c,d;b=this,(d=b.paths)==null&&(b.paths=[]),c=bi.geom.Path.fromSVG(a);return b.paths.push(c)},a.prototype.render=function(){var a,b,c,d,e,f;a=this,c=[],f=a.paths;for(d=0,e=f.length;d<e;d++)b=f[d],c.push(a.view.projectPath(b));return a.renderCallback(a,c)},a.prototype.drawPaths=function(){var a,b,c,d,e,f,g,h,i;c=this,a=c.canvas.getContext("2d"),h=c.paths,i=[];for(f=0,g=h.length;f<g;f++)d=h[f],d=c.view.projectPath(d),i.push(function(){var c,f,g,h;g=d.contours,h=[];for(c=0,f=g.length;c<f;c++)b=g[c],b.reverse(),h.push(function(){var c,d,f;f=[];for(c=0,d=b.length;c<d;c++)e=b[c],e===b[0]?f.push(a.moveTo(e[0],e[1])):f.push(a.lineTo(e[0],e[1]));return f}());return h}());return i};return a}(),T=function(){function a(a){this.zoomOut=bE(this.zoomOut,this),this.zoomIn=bE(this.zoomIn,this);var b,c,d,e,f,g,h,i;e=this,e.map=a,b=a.container,c=function(a,b){var c,d,e,f;b==null&&(b=[]),d=$('<div class="'+a+'" />');for(e=0,f=b.length;e<f;e++)c=b[e],d.append(c);return d},d=function(a){return $(a.target).addClass("md")},f=function(a){return $(a.target).removeClass("md")},i=c("plus"),i.mousedown(d),i.mouseup(f),i.click(e.zoomIn),h=c("minus"),h.mousedown(d),h.mouseup(f),h.click(e.zoomOut),g=c("zoom-control",[i,h]),b.append(g)}a.prototype.zoomIn=function(a){var b;b=this,b.map.opts.zoom+=1;return b.map.resize()},a.prototype.zoomOut=function(a){var b;b=this,b.map.opts.zoom-=1,b.map.opts.zoom<1&&(b.map.opts.zoom=1);return b.map.resize()};return a}(),bk=typeof exports!="undefined"&&exports!==null?exports:this,bi=(bA=bk.kartograph)!=null?bA:bk.kartograph={},K=function(){function a(a,b,c){c==null&&(c=0),this.lon=Number(a),this.lat=Number(b),this.alt=Number(c)}a.prototype.distance=function(a){var b,c,d,e,f,g,h,i,j;j=this,b=6371,g=Math.PI/180,e=(a.lat-j.lat)*g,f=(a.lon-j.lon)*g,h=j.lat*g,i=a.lat*g,c=Math.sin(e/2)*Math.sin(e/2)+Math.sin(f/2)*Math.sin(f/2)*Math.cos(h)*Math.cos(i),d=2*Math.atan2(Math.sqrt(c),Math.sqrt(1-c));return b*d};return a}(),I=function(){function a(b,c,d){d==null&&(d=0),a.__super__.constructor.call(this,c,b,d)}bD(a,K);return a}(),bi.LonLat=K,bi.LatLon=I,bk=typeof exports!="undefined"&&exports!==null?exports:this,bi=(bB=bk.kartograph)!=null?bB:bk.kartograph={},(bp=bi.marker)==null&&(bi.marker={}),bd=function(){function a(b){var c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A;i=this,m=["data","location","type","map"],k=["filter","tooltip","layout","group"];for(o=0,s=m.length;o<s;o++){l=m[o];if(b[l]!=null)i[l]=b[l];else throw"SymbolGroup: missing argument "+l}for(p=0,t=k.length;p<t;p++)l=k[p],b[l]!=null&&(i[l]=b[l]);c=i.type,y=c.props;for(q=0,u=y.length;q<u;q++)l=y[q],b[l]!=null&&(i[l]=b[l]);i.layers={mapcanvas:i.map.paper},z=c.layers;for(r=0,v=z.length;r<v;r++)g=z[r],j=a._layerid++,f="sl_"+j,g.type==="svg"?h=i.map.createSVGLayer(f):g.type==="html"&&(h=i.map.createHTMLLayer(f)),i.layers[g.id]=h;for(e in i.data)d=i.data[e],type(i.filter)==="function"?i.filter(d)&&i.addSymbol(d):i.addSymbol(d);i.layoutSymbols(),A=i.symbols;for(x=0,w=A.length;x<w;x++)n=A[x],n.render();type(i.tooltip)==="function"&&i.initTooltips()}a.prototype.addSymbol=function(a){var b,c,d,e,f,g,h,i,j,k;d=this,(j=d.symbols)==null&&(d.symbols=[]),b=d.type,c=d.evaluate(d.location,a),type(c)==="array"&&(c=new bi.LonLat(c[0],c[1])),f={layers:d.layers,location:c,data:a},k=b.props;for(h=0,i=k.length;h<i;h++)e=k[h],d[e]!=null&&(f[e]=d.evaluate(d[e],a));g=new b(f),d.symbols.push(g);return g},a.prototype.evaluate=function(a,b){var c;return type(a)==="function"?c=a(b):c=a},a.prototype.layoutSymbols=function(){var a,b,c,d,e,f,g,h,i,j,k;c=this,j=c.symbols;for(h=0,i=j.length;h<i;h++){f=j[h],b=f.location;if(type(b)==="string"){k=b.split("."),a=k[0],e=k[1],d=c.map.getLayerPath(a,e);if(d!=null)g=c.map.viewBC.project(d.path.centroid());else continue}else g=c.map.lonlat2xy(b);f.x=g[0],f.y=g[1]}if(c.layout==="group")return c.groupLayout()},a.prototype.groupLayout=function(){var a,b,c;a=this,(c=a.gsymbols)==null&&(a.gsymbols=[]);return b=!0},a.prototype.initTooltips=function(){var a,b,c,d,e,f,g,h,i,j,k,l;b=this,e=b.tooltip,k=b.symbols;for(g=0,i=k.length;g<i;g++){d=k[g],a={position:{target:"mouse",viewport:$(window),adjust:{x:7,y:7}},show:{delay:20},content:{}},console.log(d,d.data),f=e(d.data),type(f)==="string"?a.content.text=f:type(f)==="array"&&(a.content.title=f[0],a.content.text=f[1]),l=d.nodes();for(h=0,j=l.length;h<j;h++)c=l[h],$(c).qtip(a)}};return a}(),bd._layerid=0,bi.SymbolGroup=bd,bc=function(){function a(a){var b;b=this,b.location=a.location,b.data=a.data,b.layers=a.layers,b.x=a.x,b.y=a.y}a.prototype.init=function(){},a.prototype.overlaps=function(a){return!1},a.prototype.nodes=function(){return[]};return a}(),g=function(){function a(b){var c,d,e,f;c=this,a.__super__.constructor.call(this,b),c.radius=(d=b.radius)!=null?d:4,c.style=(e=b.style)!=null?e:"",c["class"]=(f=b["class"])!=null?f:""}bD(a,bc),a.prototype.overlaps=function(a){var b,c,d,e,f,g,h,i,j,k,l;d=this,k=[d.x,d.y,d.radius],g=k[0],i=k[1],e=k[2],l=[a.x,a.y,a.radius],h=l[0],j=l[1],f=l[2];if(g-e>h+f||g+e<h-f||i-e>j+f||i+e<j-f)return!1;b=g-h,c=i-j;return b*b+c*c>(e+f)*(e+f)?!1:!0},a.prototype.render=function(a){var b;b=this,b.path=b.layers.a.circle(b.x,b.y,b.radius),b.update();return b},a.prototype.update=function(){var a,b;a=this,a.path.attr({x:a.x,y:a.y,r:a.radius}),b=a.path,b.node.setAttribute("style",a.style),b.node.setAttribute("class",a["class"]);return a},a.prototype.clear=function(){var a;a=this,a.path.remove();return a},a.prototype.nodes=function(){var a;a=this;return[a.path.node]};return a}(),g.props=["radius","style","class"],g.layers=[{id:"a",type:"svg"}],bi.Bubble=g,A=function(){function a(b){var c,d,e,f;c=this,a.__super__.constructor.call(this,b),c.text=(d=b.text)!=null?d:"",c.style=(e=b.style)!=null?e:"",c["class"]=(f=b["class"])!=null?f:""}bD(a,bc),a.prototype.render=function(a){var b,c,d;d=this,b=$("<div>"+d.text+"</div>"),b.css({width:"50px",position:"absolute",left:"-25px","text-align":"center"}),d.lbl=c=$('<div class="label" />'),c.append(b),d.layers.lbl.append(c),b.css({height:b.height()+"px",top:b.height()*-0.4+"px"}),d.update();return d},a.prototype.update=function(){var a;a=this;return a.lbl.css({position:"absolute",left:a.x+"px",top:a.y+"px"})},a.prototype.clear=function(){var a;a=this,a.lbl.remove();return a},a.prototype.nodes=function(){var a;a=this;return[a.lbl[0]]};return a}(),A.props=["text","style","class"],A.layers=[{id:"lbl",type:"html"}],bi.HtmlLabel=A,bb=function(){function a(b){var c,d,e,f;c=this,a.__super__.constructor.call(this,b),c.text=(d=b.text)!=null?d:"",c.style=(e=b.style)!=null?e:"",c["class"]=(f=b["class"])!=null?f:""}bD(a,bc),a.prototype.render=function(a){var b,c;c=this,c.lbl=b=c.layers.mapcanvas.text(c.x,c.y,c.text),c.update();return c},a.prototype.update=function(){var a;a=this,a.lbl.attr({x:a.x,y:a.y}),a.lbl.node.setAttribute("style",a.style);return a.lbl.node.setAttribute("class",a["class"])},a.prototype.clear=function(){var a;a=this,a.lbl.remove();return a},a.prototype.nodes=function(){var a;a=this;return[a.lbl.node]};return a}(),bb.props=["text","style","class"],bb.layers=[],bi.Label=bb,B=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,bc);return a}(),B.props=["icon"],B.layer=["html"],O=function(){function a(a){var b;b=this,a.length===2&&(a=new bi.LonLat(a[0],a[1])),b.lonlat=a,b.visible=!0}a.prototype.render=function(a,b,c,d){};return a}(),bi.marker.MapMarker=O,G=function(){function a(b,c){a.__super__.constructor.call(this,b),this.label=c}bD(a,O);return a}(),bi.marker.LabelMarker=G,p=function(){function a(b,c,d,e){e==null&&(e=null),a.__super__.constructor.call(this,b,c),this.rad=d,this.color=e}bD(a,G),a.prototype.render=function(a,b,c,d){var e,f;e=this,e.path=d.circle(a,b,this.rad),f=e.path.node,f.setAttribute("class","dotMarker"),f.setAttribute("title",this.label);if(this.color!=null)return f.setAttribute("style","fill:"+this.color)},a.prototype.clear=function(){return this.path.remove()};return a}(),bi.marker.DotMarker=p,C=function(){function a(a,b){}bD(a,O);return a}(),bi.marker.IconMarker=C,H=function(){function a(b){var c,d,e,f;c=this,a.__super__.constructor.call(this,b.ll),c.icon_src=b.icon,c.label_txt=b.label,c.className=(d=b.className)!=null?d:"marker",c.dx=(e=b.dx)!=null?e:0,c.dy=(f=b.dy)!=null?f:0}bD(a,O),a.prototype.render=function(a,b,c,d){var e;e=this,e.markerDiv||(e.icon=$('<img src="'+e.icon_src+'" class="icon"/>'),e.label=$('<div class="label">'+e.label_txt+"</div>"),e.markerDiv=$('<div class="'+e.className+'" />'),e.markerDiv.append(e.icon),e.markerDiv.append(e.label),c.append(e.markerDiv));return e.markerDiv.css({position:"absolute",left:a+e.dx+"px",top:b+e.dy+"px"})};return a}(),bi.marker.LabeledIconMarker=H,h=function(){function a(b,c,d){d==null&&(d="bubble"),a.__super__.constructor.call(this,b)}bD(a,O);return a}(),bk=typeof exports!="undefined"&&exports!==null?exports:this,bi=(bq=bk.kartograph)!=null?bq:bk.kartograph={},(br=bi.geom)==null&&(bi.geom={}),U=function(){function a(a,b,c){var d;c==null&&(c=!0),d=this,d.type=a,d.contours=b,d.closed=c}a.prototype.clipToBBox=function(a){throw"path clipping is not implemented yet"},a.prototype.toSVG=function(a){var b;b=this.svgString();return a.path(b)},a.prototype.svgString=function(){var a,b,c,d,e,f,g,h,i,j,k,l,m;d=this,e="",c=d.closed?"Z M":"M",l=d.contours;for(h=0,j=l.length;h<j;h++){a=l[h],b=!0,e+=e===""?"M":c;for(i=0,k=a.length;i<k;i++)m=a[i],f=m[0],g=m[1],b||(e+="L"),e+=f+","+g,b=!1}d.closed&&(e+="Z");return e},a.prototype.area=function(){var a,b,c,d,e,f,g,h;d=this;if(d.areas!=null)return d._area;d.areas=[],d._area=0,g=d.contours;for(e=0,f=g.length;e<f;e++){b=g[e],a=0;for(c=0,h=b.length-2;0<=h?c<=h:c>=h;0<=h?c++:c--)a+=b[c][0]*b[c+1][1]-b[c+1][0]*b[c][1];a*=.5,a=a,d.areas.push(a),d._area+=a}return d._area},a.prototype.centroid=function(){var a,b,c,d,e,f,g,h,i,j,k,l,m;i=this;if(i._centroid!=null)return i._centroid;b=i.area(),d=e=0;for(f=0,l=i.contours.length-1;0<=l?f<=l:f>=l;0<=l?f++:f--){c=i.contours[f],a=i.areas[f],j=k=0;for(g=0,m=c.length-2;0<=m?g<=m:g>=m;0<=m?g++:g--)h=c[g][0]*c[g+1][1]-c[g+1][0]*c[g][1],j+=(c[g][0]+c[g+1][0])*h,k+=(c[g][1]+c[g+1][1])*h;h=1/(6*a),j*=h,k*=h,h=a/b,d+=j*h,e+=k*h}i._centroid=[d,e];return i._centroid};return a}(),bi.geom.Path=U,k=function(){function a(b,c,d){this.x=b,this.y=c,this.r=d,a.__super__.constructor.call(this,"circle",null,!0)}bD(a,U),a.prototype.toSVG=function(a){var b;b=this;return a.circle(b.x,b.y,b.r)},a.prototype.centroid=function(){var a;a=this;return[a.x,a.y]},a.prototype.area=function(){var a;a=this;return Math.PI*a.r*m.r};return a}(),bi.geom.Circle=k,U.fromSVG=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v;e=[],m=a.nodeName,k=null;if(m==="path"){h=a.getAttribute("d").trim(),b=h[h.length-1]==="Z",l=b?"Z M":"M",h=h.substring(1,h.length-(b?1:0)),t=h.split(l);for(p=0,r=t.length;p<r;p++){d=t[p],c=[];if(d!==""){u=d.split("L");for(q=0,s=u.length;q<s;q++)i=u[q],v=i.split(","),n=v[0],o=v[1],c.push([Number(n),Number(o)]);e.push(c)}}k=new bi.geom.Path(m,e,b)}else m==="circle"&&(f=a.getAttribute("cx"),g=a.getAttribute("cy"),j=a.getAttribute("r"),k=new bi.geom.Circle(f,g,j));return k},J=function(){function a(a){this.points=a}a.prototype.clipToBBox=function(b){var c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t;l=this,c=(new bi.geom.clipping.CohenSutherland).clip,k=[],f=[],e=!1;for(d=0,q=l.points.length-2;0<=q?d<=q:d>=q;0<=q?d++:d--){r=l.points[d],g=r[0],h=r[1],s=l.points[d+1],i=s[0],j=s[1];try{t=c(b,g,h,i,j),m=t[0],o=t[1],n=t[2],p=t[3],e=!0,k.push([m,o]),(i!==n||j!==o||d===len(l.points)-2)&&k.push([n,p])}catch(u){e&&k.length>1&&(f.push(new a(k)),k=[]),e=!1}}k.length>1&&f.push(new a(k));return f},a.prototype.toSVG=function(){var a,b,c,d,e,f,g,h;b=this,a=[],g=b.points;for(e=0,f=g.length;e<f;e++)h=g[e],c=h[0],d=h[1],a.push(c+","+d);return"M"+a.join("L")};return a}(),bi.geom.Line=J,bk=typeof exports!="undefined"&&exports!==null?exports:this,bi=(bs=bk.kartograph)!=null?bs:bk.kartograph={},bm=bi.proj={},Function.prototype.bind=function(a){var b;b=this;return function(){return b.apply(a,arguments)}},V=function(){function a(a){var b,c,d;b=this,b.lon0=(c=a.lon0)!=null?c:0,b.lat0=(d=a.lat0)!=null?d:0,b.PI=Math.PI,b.HALFPI=b.PI*.5,b.QUARTERPI=b.PI*.25,b.RAD=b.PI/180,b.DEG=180/b.PI,b.lam0=b.rad(this.lon0),b.phi0=b.rad(this.lat0),b.minLat=-90,b.maxLat=90}a.prototype.rad=function(a){return a*this.RAD},a.prototype.deg=function(a){return a*this.DEG},a.prototype.plot=function(a,b){var c,d,e,f,g,h,i,j,k,l,m;b==null&&(b=!0),f=[],c=!0;for(j=0,k=a.length;j<k;j++)l=a[j],e=l[0],d=l[1],g=this._visible(e,d),g&&(c=!1),m=this.project(e,d),h=m[0],i=m[1],!g&&b?f.push(this._truncate(h,i)):f.push([h,i]);return c?null:[f]},a.prototype.sea=function(){var a,b,c,d,e,f,g,h,i,j;f=this,e=f.project.bind(this),d=[],a=f.lon0,f.lon0=0;for(c=-180;c<=180;c++)d.push(e(c,f.maxLat));for(b=g=f.maxLat,h=f.minLat;g<=h?b<=h:b>=h;g<=h?b++:b--)d.push(e(180,b));for(c=180;c>=-180;c--)d.push(e(c,f.minLat));for(b=i=f.minLat,j=f.maxLat;i<=j?b<=j:b>=j;i<=j?b++:b--)d.push(e(-180,b));f.lon0=a;return d},a.prototype.world_bbox=function(){var a,b,c,d,e,f;b=this.project.bind(this),d=this.sea(),a=new bi.BBox;for(e=0,f=d.length;e<f;e++)c=d[e],a.update(c[0],c[1]);return a};return a}(),V.fromXML=function(a){var b,c,d,e,f;d=a.getAttribute("id"),e={};for(c=0,f=a.attributes.length-1;0<=f?c<=f:c>=f;0<=f?c++:c--)b=a.attributes[c],b.name!=="id"&&(e[b.name]=b.value);return new bi.proj[d](e)},bi.Proj=V,o=function(){function a(b){var c,d;c=this,c.flip=Number(b.flip)||0,c.flip===1&&(b.lon0=(d=-b.lon0)!=null?d:0),a.__super__.constructor.call(this,b)}bD(a,V),a.prototype._visible=function(a,b){return!0},a.prototype.clon=function(a){a-=this.lon0,a<-180?a+=360:a>180&&(a-=360);return a},a.prototype.ll=function(a,b){return this.flip===1?[-a,-b]:[a,b]};return a}(),t=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,o),a.prototype.project=function(a,b){var c;c=this.ll(a,b),a=c[0],b=c[1],a=this.clon(a);return[a*Math.cos(this.phi0)*1e3,b*-1*1e3]};return a}(),bm.lonlat=t,i=function(){function a(b){var c;a.__super__.constructor.call(this,b),this.lat1=(c=b.lat1)!=null?c:0,this.phi1=this.rad(this.lat1)}bD(a,o),a.prototype.project=function(a,b){var c,d,e,f,g;g=this.ll(a,b),a=g[0],b=g[1],c=this.rad(this.clon(a)),d=this.rad(b*-1),e=c*Math.cos(this.phi1),f=Math.sin(d)/Math.cos(this.phi1);return[e*1e3,f*1e3]};return a}(),bm.cea=i,v=function(){function a(b,c){a.__super__.constructor.call(this,b,45)}bD(a,i);return a}(),bm.gallpeters=v,z=function(){function a(b){b.lat0=37.7,a.__super__.constructor.call(this,b)}bD(a,i);return a}(),bm.hobodyer=z,e=function(){function a(b){b.lat0=30,a.__super__.constructor.call(this,b)}bD(a,i);return a}(),bm.behrmann=e,d=function(){function a(b){b.lat0=50,a.__super__.constructor.call(this,b)}bD(a,i);return a}(),bm.balthasart=d,P=function(){function a(b){a.__super__.constructor.call(this,b),this.minLat=-85,this.maxLat=85}bD(a,o),a.prototype.project=function(a,b){var c,d,e,f,g,h,i;f=this,i=f.ll(a,b),a=i[0],b=i[1],d=Math,c=f.rad(f.clon(a)),e=f.rad(b*-1),g=c*1e3,h=d.log((1+d.sin(e))/d.cos(e))*1e3;return[g,h]};return a}(),bm.mercator=P,X=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,o);return a}(),R=function(){function a(b){var c;a.__super__.constructor.call(this,b),c=this,c.A0=.8707,c.A1=-0.131979,c.A2=-0.013791,c.A3=.003971,c.A4=-0.001529,c.B0=1.007226,c.B1=.015085,c.B2=-0.044475,c.B3=.028874,c.B4=-0.005916,c.C0=c.B0,c.C1=3*c.B1,c.C2=7*c.B2,c.C3=9*c.B3,c.C4=11*c.B4,c.EPS=1e-11,c.MAX_Y=.8707*.52*Math.PI;return}bD(a,X),a.prototype.project=function(a,b){var c,d,e,f,g,h,i,j;g=this,j=g.ll(a,b),a=j[0],b=j[1],c=g.rad(g.clon(a)),d=g.rad(b*-1),e=d*d,f=e*e,h=c*(g.A0+e*(g.A1+e*(g.A2+f*e*(g.A3+e*g.A4))))*180+500,i=d*(g.B0+e*(g.B1+f*(g.B2+g.B3*e+g.B4*f)))*180+270;return[h,i]};return a}(),bm.naturalearth=R,Y=function(){function a(b){var c;a.__super__.constructor.call(this,b),c=this,c.X=[1,-5.67239e-12,-0.0000715511,311028e-11,.9986,-0.000482241,-0.000024897,-0.00000133094,.9954,-0.000831031,-0.000044861,-9.86588e-7,.99,-0.00135363,-0.0000596598,367749e-11,.9822,-0.00167442,-0.0000044975,-0.00000572394,.973,-0.00214869,-0.0000903565,1.88767e-8,.96,-0.00305084,-0.0000900732,164869e-11,.9427,-0.00382792,-0.0000653428,-0.00000261493,.9216,-0.00467747,-0.000104566,48122e-10,.8962,-0.00536222,-0.0000323834,-0.00000543445,.8679,-0.00609364,-0.0001139,332521e-11,.835,-0.00698325,-0.0000640219,9.34582e-7,.7986,-0.00755337,-0.0000500038,9.35532e-7,.7597,-0.00798325,-0.0000359716,-0.00000227604,.7186,-0.00851366,-0.000070112,-0.00000863072,.6732,-0.00986209,-0.000199572,191978e-10,.6213,-0.010418,883948e-10,624031e-11,.5722,-0.00906601,181999e-9,624033e-11,.5322,0,0,0],c.Y=[0,.0124,3.72529e-10,1.15484e-9,.062,.0124001,1.76951e-8,-5.92321e-9,.124,.0123998,-7.09668e-8,2.25753e-8,.186,.0124008,2.66917e-7,-8.44523e-8,.248,.0123971,-9.99682e-7,3.15569e-7,.31,.0124108,373349e-11,-0.0000011779,.372,.0123598,-0.000013935,439588e-11,.434,.0125501,520034e-10,-0.0000100051,.4968,.0123198,-0.0000980735,922397e-11,.5571,.0120308,402857e-10,-0.0000052901,.6176,.0120369,-0.0000390662,7.36117e-7,.6769,.0117015,-0.0000280246,-8.54283e-7,.7346,.0113572,-0.0000408389,-5.18524e-7,.7903,.0109099,-0.0000486169,-0.0000010718,.8435,.0103433,-0.0000646934,5.36384e-9,.8936,.00969679,-0.0000646129,-0.00000854894,.9394,.00840949,-0.000192847,-0.00000421023,.9761,.00616525,-0.000256001,-0.00000421021,1,0,0,0],c.NODES=18,c.FXC=.8487,c.FYC=1.3523,c.C1=11.459155902616464,c.RC1=.08726646259971647,c.ONEEPS=1.000001,c.EPS=1e-8;return}bD(a,X),a.prototype._poly=function(a,b,c){return a[b]+c*(a[b+1]+c*(a[b+2]+c*
a[b+3]))},a.prototype.project=function(a,b){var c,d,e,f,g,h,i,j;g=this,j=g.ll(a,b),a=j[0],b=j[1],a=g.clon(a),d=g.rad(a),e=g.rad(b*-1),f=Math.abs(e),c=Math.floor(f*g.C1),c>=g.NODES&&(c=g.NODES-1),f=g.deg(f-g.RC1*c),c*=4,h=g._poly(g.X,c,f)*g.FXC*d,i=g._poly(g.Y,c,f)*g.FYC,e<0&&(i=-i);return[h,i]};return a}(),bm.robinson=Y,q=function(){function a(b){var c;a.__super__.constructor.call(this,b),c=this,c.C_x=.4222382003157712,c.C_y=1.3265004281770023,c.RC_y=.7538633073600218,c.C_p=3.5707963267948966,c.RC_p=.2800495767557787,c.EPS=1e-7,c.NITER=6}bD(a,X),a.prototype.project=function(a,b){var c,d,e,f,g,h,i,j,k,l,m;h=this,m=h.ll(a,b),a=m[0],b=m[1],f=h.rad(h.clon(a)),g=h.rad(b*-1),i=h.C_p*Math.sin(g),c=g*g,g*=.895168+c*(.0218849+c*.00826809),e=h.NITER;while(e>0){d=Math.cos(g),j=Math.sin(g),c=(g+j*(d+2)-i)/(1+d*(d+2)-j*j),g-=c;if(Math.abs(c)<h.EPS)break;e-=1}e===0?(k=h.C_x*f,l=g<0?-h.C_y:h.C_y):(k=h.C_x*f*(1+Math.cos(g)),l=h.C_y*Math.sin(g));return[k,l]};return a}(),bm.eckert4=q,_=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,X),a.prototype.project=function(a,b){var c,d,e,f,g,h;d=this,h=d.ll(a,b),a=h[0],b=h[1],c=d.rad(d.clon(a)),e=d.rad(b*-1),f=c*Math.cos(e),g=e;return[f,g]};return a}(),bm.sinusoidal=_,Q=function(){function a(b,c,d,e,f){var g,h,i,j;c==null&&(c=1.5707963267948966),d==null&&(d=null),e==null&&(e=null),f==null&&(f=null),a.__super__.constructor.call(this,b),g=this,g.MAX_ITER=10,g.TOLERANCE=1e-7,c!=null?(h=c+c,j=Math.sin(c),i=Math.sqrt(Math.PI*2*j/(h+Math.sin(h))),g.cx=2*i/Math.PI,g.cy=i/j,g.cp=h+Math.sin(h)):d!=null&&e!=null&&typeof cz!="undefined"&&cz!==null?(g.cx=d,g.cy=e,g.cp=f):console.error("kartograph.proj.Mollweide: either p or cx,cy,cp must be defined")}bD(a,X),a.prototype.project=function(a,b){var c,d,e,f,g,h,i,j,k,l,m;h=this,m=h.ll(a,b),a=m[0],b=m[1],g=Math,c=g.abs,f=h.rad(h.clon(a)),i=h.rad(b),e=h.cp*g.sin(i),d=h.MAX_ITER;while(d!==0){j=(i+g.sin(i)-e)/(1+g.cos(i)),i-=j;if(c(j)<h.TOLERANCE)break;d-=1}d===0?i=i>=0?h.HALFPI:-h.HALFPI:i*=.5,k=1e3*h.cx*f*g.cos(i),l=1e3*h.cy*g.sin(i);return[k,l*-1]};return a}(),bm.mollweide=Q,bf=function(){function a(b){a.__super__.constructor.call(this,b,1.0471975511965976)}bD(a,Q);return a}(),bm.wagner4=bf,bg=function(){function a(b){a.__super__.constructor.call(this,b,null,.90977,1.65014,3.00896)}bD(a,Q);return a}(),bm.wagner5=bg,L=function(){function c(){c.__super__.constructor.apply(this,arguments)}var a,b;bD(c,X),b=-89,a=89,c.prototype.project=function(a,b){var c,d,e,f,g,h,i;e=this,i=e.ll(a,b),a=i[0],b=i[1],d=Math,c=e.rad(e.clon(a)),f=e.rad(b),f===e.phi0?g=c*d.cos(e.phi0):g=c*(f-e.phi0)/(d.log(d.tan(e.QUARTERPI+f*.5))-d.log(d.tan(e.QUARTERPI+e.phi0*.5))),g*=1e3,h=1e3*(f-e.phi0);return[g,h*-1]};return c}(),bm.loximuthal=L,b=function(){function a(b,c){var d;c==null&&(c=1e3),a.__super__.constructor.call(this,b),d=this,d.r=c,d.elevation0=d.to_elevation(d.lat0),d.azimuth0=d.to_azimuth(d.lon0)}bD(a,V),a.prototype.to_elevation=function(a){var b;b=this;return(a+90)/180*b.PI-b.HALFPI},a.prototype.to_azimuth=function(a){var b;b=this;return(a+180)/360*b.PI*2-b.PI},a.prototype._visible=function(a,b){var c,d,e,f,g;g=this,f=Math,e=g.to_elevation(b),c=g.to_azimuth(a),d=f.sin(e)*f.sin(g.elevation0)+f.cos(g.elevation0)*f.cos(e)*f.cos(c-g.azimuth0);return d>=0},a.prototype._truncate=function(a,b){var c,d,e,f,g;c=Math,d=this.r,e=c.atan2(b-d,a-d),f=d+d*c.cos(e),g=d+d*c.sin(e);return[f,g]},a.prototype.sea=function(){var a,b,c,d;b=[],d=this.r,a=Math;for(c=0;c<=360;c++)b.push([d+a.cos(this.rad(c))*d,d+a.sin(this.rad(c))*d]);return b},a.prototype.world_bbox=function(){var a;a=this.r;return new bi.BBox(0,0,a*2,a*2)};return a}(),S=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,b),a.prototype.project=function(a,b){var c,d,e,f,g,h,i,j;f=this,e=Math,d=f.to_elevation(b),c=f.to_azimuth(a),h=f.r*e.cos(d)*e.sin(c-f.azimuth0),j=-f.r*(e.cos(f.elevation0)*e.sin(d)-e.sin(f.elevation0)*e.cos(d)*e.cos(c-f.azimuth0)),g=f.r+h,i=f.r+j;return[g,i]};return a}(),bm.ortho=S,E=function(){function a(b){a.__super__.constructor.call(this,b),this.scale=Math.sqrt(2)*.5}bD(a,b),a.prototype.project=function(a,b){var c,d,e,f,g,h,i,j,k,l;g=this.rad(b),e=this.rad(a),f=Math,h=f.sin,c=f.cos,d=f.pow(2/(1+h(this.phi0)*h(g)+c(this.phi0)*c(g)*c(e-this.lam0)),.5),d*=this.scale,j=this.r*d*c(g)*h(e-this.lam0),l=-this.r*d*(c(this.phi0)*h(g)-h(this.phi0)*c(g)*c(e-this.lam0)),i=this.r+j,k=this.r+l;return[i,k]};return a}(),bm.laea=E,ba=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,b),a.prototype.project=function(a,b){var c,d,e,f,g,h,i,j,k,l,m;h=this.rad(b),f=this.rad(a),g=Math,i=g.sin,c=g.cos,e=.5,d=2*e/(1+i(this.phi0)*i(h)+c(this.phi0)*c(h)*c(f-this.lam0)),k=this.r*d*c(h)*i(f-this.lam0),m=-this.r*d*(c(this.phi0)*i(h)-i(this.phi0)*c(h)*c(f-this.lam0)),j=this.r+k,l=this.r+m;return[j,l]};return a}(),bm.stereo=ba,Z=function(){function a(b){var c,d,e,f,g,h,i,j;a.__super__.constructor.call(this,{lon0:0,lat0:0}),this.dist=(h=b.dist)!=null?h:3,this.up=this.rad((i=b.up)!=null?i:0),this.tilt=this.rad((j=b.tilt)!=null?j:0),this.scale=1,f=Number.MAX_VALUE,e=Number.MAX_VALUE*-1;for(c=0;c<=179;c++)for(d=0;d<=360;d++)g=this.project(d-180,c-90),f=Math.min(g[0],f),e=Math.max(g[0],e);this.scale=this.r*2/(e-f),a.__super__.constructor.call(this,b);return}bD(a,b),a.prototype.project=function(a,b,c){var d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x;c==null&&(c=0),m=this.rad(b),k=this.rad(a),l=Math,p=l.sin,f=l.cos,n=this.r,o=n*(c+6371)/3671,g=p(this.phi0)*p(m)+f(this.phi0)*f(m)*f(k-this.lam0),j=(this.dist-1)/(this.dist-g),j=(this.dist-1)/(this.dist-g),j*=this.scale,t=o*j*f(m)*p(k-this.lam0),w=-o*j*(f(this.phi0)*p(m)-p(this.phi0)*f(m)*f(k-this.lam0)),i=f(this.up),r=p(this.up),h=f(this.tilt),q=p(this.tilt),e=o*(this.dist-1),d=(w*i+t*r)*p(this.tilt/e)+h,u=(t*i-w*r)*f(this.tilt/d),x=(w*i+t*r)/d,s=n+u,v=n+x;return[s,v]},a.prototype._visible=function(a,b){var c,d,e,f;e=this.to_elevation(b),c=this.to_azimuth(a),f=Math,d=f.sin(e)*f.sin(this.elevation0)+f.cos(this.elevation0)*f.cos(e)*f.cos(c-this.azimuth0);return d>=1/this.dist},a.prototype.sea=function(){var a,b,c,d;b=[],d=this.r,a=Math;for(c=0;c<=360;c++)b.push([d+a.cos(this.rad(c))*d,d+a.sin(this.rad(c))*d]);return b};return a}(),bm.satellite=Z,r=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,b),a.prototype.project=function(a,b){var c,d,e,f,g,h,i,j,k,l,m,n;i=this.rad(b),g=this.rad(a),h=Math,j=h.sin,d=h.cos,e=j(this.phi0)*j(i)+d(this.phi0)*d(i)*d(g-this.lam0),c=h.acos(e),f=.325*c/j(c),l=this.r*f*d(i)*j(g-this.lam0),n=-this.r*f*(d(this.phi0)*j(i)-j(this.phi0)*d(i)*d(g-this.lam0)),k=this.r+l,m=this.r+n;return[k,m]},a.prototype._visible=function(a,b){return!0};return a}(),bm.equi=r,a=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,r),a.prototype.project=function(a,b){return[x,y]},a.prototype._visible=function(a,b){return!0};return a}(),bm.aitoff=a,n=function(){function a(b){var c,d,e;c=this,a.__super__.constructor.call(this,b),c.lat1=(d=b.lat1)!=null?d:30,c.phi1=c.rad(c.lat1),c.lat2=(e=b.lat2)!=null?e:50,c.phi2=c.rad(c.lat2)}bD(a,V),a.prototype._visible=function(a,b){return!0},a.prototype._truncate=function(a,b){return[a,b]},a.prototype.clon=function(a){a-=this.lon0,a<-180?a+=360:a>180&&(a-=360);return a};return a}(),F=function(){function a(b){var c,d,e,f,g,h,i,j,k,l,m,n,o;k=this,a.__super__.constructor.call(this,b),g=Math,o=[g.sin,g.cos,g.abs,g.log,g.tan,g.pow],l=o[0],e=o[1],c=o[2],bj=o[3],n=o[4],i=o[5],k.n=h=m=l(k.phi1),f=e(k.phi1),j=c(k.phi1-k.phi2)>=1e-10,j&&(h=bj(f/e(k.phi2))/bj(n(k.QUARTERPI+.5*k.phi2)/n(k.QUARTERPI+.5*k.phi1))),k.c=d=f*i(n(k.QUARTERPI+.5*k.phi1),h)/h,c(c(k.phi0)-k.HALFPI)<1e-10?k.rho0=0:k.rho0=d*i(n(k.QUARTERPI+.5*k.phi0),-h),k.minLat=-60,k.maxLat=85}bD(a,n),"Lambert Conformal Conic Projection (spherical)",a.prototype.project=function(a,b){var c,d,e,f,g,h,i,j,k,l,m,n,o,p,q;l=this,i=l.rad(b),e=l.rad(l.clon(a)),g=Math,q=[g.sin,g.cos,g.abs,g.log,g.tan,g.pow],m=q[0],d=q[1],c=q[2],bj=q[3],n=q[4],j=q[5],h=l.n,c(c(i)-l.HALFPI)<1e-10?k=0:k=l.c*j(n(l.QUARTERPI+.5*i),-h),f=e*h,o=1e3*k*m(f),p=1e3*l.rho0-k*d(f);return[o,p*-1]};return a}(),bm.lcc=F,W=function(){function a(){a.__super__.constructor.apply(this,arguments)}bD(a,n);return a}(),be=function(){function a(a,b,c,d,e,f){var g;g=this,g.bbox=a,g.width=b,g.padding=d!=null?d:0,g.halign=e!=null?e:"center",g.valign=f!=null?f:"center",g.height=c,g.scale=Math.min((b-d*2)/a.width,(c-d*2)/a.height)}a.prototype.project=function(a,b){var c,d,e,f,g,h,i;b==null&&(b=a[1],a=a[0]),e=this,f=e.scale,c=e.bbox,d=e.height,g=e.width,h=e.halign==="center"?(g-c.width*f)*.5:e.halign==="left"?e.padding*f:g-(c.width-e.padding)*f,i=e.valign==="center"?(d-c.height*f)*.5:e.valign==="top"?e.padding*f:0,a=(a-c.left)*f+h,b=(b-c.top)*f+i;return[a,b]},a.prototype.projectPath=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p;d=this;if(a.type==="path"){c=[],m=a.contours;for(i=0,k=m.length;i<k;i++){e=m[i],b=[];for(j=0,l=e.length;j<l;j++)n=e[j],g=n[0],h=n[1],o=d.project(g,h),g=o[0],h=o[1],b.push([g,h]);c.push(b)}return new bi.geom.Path(a.type,c,a.closed)}if(a.type==="circle"){p=d.project(a.x,a.y),g=p[0],h=p[1],f=a.r*d.scale;return new bi.geom.Circle(g,h,f)}},a.prototype.asBBox=function(){var a;a=this;return new bi.BBox(0,0,a.width,a.height)};return a}(),be.fromXML=function(a){var b,d,e,f,g;g=Number(a.getAttribute("w")),e=Number(a.getAttribute("h")),f=Number(a.getAttribute("padding")),d=a.getElementsByTagName("bbox")[0],b=c.fromXML(d);return new bi.View(b,g,e,f)},bk=typeof exports!="undefined"&&exports!==null?exports:this,(bt=bk.kartograph)==null&&(bk.kartograph={}),bk.kartograph.View=be}).call(this)(function() {

  /**
      chroma.js - a neat JS lib for color conversions
      Copyright (C) 2011  Gregor Aisch
  
  	The JavaScript code in this page is free software: you can
      redistribute it and/or modify it under the terms of the GNU
      General Public License (GNU GPL) as published by the Free Software
      Foundation, either version 3 of the License, or (at your option)
      any later version.  The code is distributed WITHOUT ANY WARRANTY;
      without even the implied warranty of MERCHANTABILITY or FITNESS
      FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
  
      As additional permission under GNU GPL version 3 section 7, you
      may distribute non-source (e.g., minimized or compacted) forms of
      that code without the copy of the GNU GPL normally required by
      section 4, provided you include this license notice and a URL
      through which recipients can access the Corresponding Source.  
      
      @source: https://github.com/gka/chroma.js
  */

  var CSSColors, Categories, Color, ColorScale, Diverging, Ramp, chroma, root, type, _ref, _ref2;
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  chroma = (_ref = root.chroma) != null ? _ref : root.chroma = {};

  chroma.version = "0.2.5";

  Color = (function() {

    /*
    	data type for colors
    	
    	eg.
    	new Color() // white
    	new Color(120,.8,.5) // defaults to hsl color
    	new Color([120,.8,.5]) // this also works
    	new Color(255,100,50,'rgb') //  color using RGB
    	new Color('#ff0000') // or hex value
    */

    function Color(x, y, z, m) {
      var me, _ref2;
      me = this;
      if (!(x != null) && !(y != null) && !(z != null) && !(m != null)) {
        x = [255, 0, 255];
      }
      if (type(x) === "array" && x.length === 3) {
        if (m == null) m = y;
        _ref2 = x, x = _ref2[0], y = _ref2[1], z = _ref2[2];
      }
      if (type(x) === "string") {
        m = 'hex';
      } else {
        if (m == null) m = 'rgb';
      }
      if (m === 'rgb') {
        me.rgb = [x, y, z];
      } else if (m === 'hsl') {
        me.rgb = Color.hsl2rgb(x, y, z);
      } else if (m === 'hsv') {
        me.rgb = Color.hsv2rgb(x, y, z);
      } else if (m === 'hex') {
        me.rgb = Color.hex2rgb(x);
      } else if (m === 'lab') {
        me.rgb = Color.lab2rgb(x, y, z);
      } else if (m === 'csl') {
        me.rgb = Color.csl2rgb(x, y, z);
      } else if (m === 'hsi') {
        me.rgb = Color.hsi2rgb(x, y, z);
      }
    }

    Color.prototype.hex = function() {
      return Color.rgb2hex(this.rgb);
    };

    Color.prototype.toString = function() {
      return this.hex();
    };

    Color.prototype.hsl = function() {
      return Color.rgb2hsl(this.rgb);
    };

    Color.prototype.hsv = function() {
      return Color.rgb2hsv(this.rgb);
    };

    Color.prototype.lab = function() {
      return Color.rgb2lab(this.rgb);
    };

    Color.prototype.csl = function() {
      return Color.rgb2csl(this.rgb);
    };

    Color.prototype.hsi = function() {
      return Color.rgb2hsi(this.rgb);
    };

    Color.prototype.interpolate = function(f, col, m) {
      /*
      		interpolates between colors
      */
      var dh, hue, hue0, hue1, lbv, lbv0, lbv1, me, sat, sat0, sat1, xyz0, xyz1;
      me = this;
      if (m == null) m = 'rgb';
      if (type(col) === "string") col = new Color(col);
      if (m === 'hsl' || m === 'hsv' || m === 'csl' || m === 'hsi') {
        if (m === 'hsl') {
          xyz0 = me.hsl();
          xyz1 = col.hsl();
        } else if (m === 'hsv') {
          xyz0 = me.hsv();
          xyz1 = col.hsv();
        } else if (m === 'csl') {
          xyz0 = me.csl();
          xyz1 = col.csl();
        } else if (m === 'hsi') {
          xyz0 = me.hsi();
          xyz1 = col.hsi();
        }
        hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];
        hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];
        if (!isNaN(hue0) && !isNaN(hue1)) {
          if (hue1 > hue0 && hue1 - hue0 > 180) {
            dh = hue1 - (hue0 + 360);
          } else if (hue1 < hue0 && hue0 - hue1 > 180) {
            dh = hue1 + 360 - hue0;
          } else {
            dh = hue1 - hue0;
          }
          hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
          hue = hue0;
          if (lbv1 === 1 || lbv1 === 0) sat = sat0;
        } else if (!isNaN(hue1)) {
          hue = hue1;
          if (lbv0 === 1 || lbv0 === 0) sat = sat1;
        } else {
          hue = void 0;
        }
        if (sat == null) sat = sat0 + f * (sat1 - sat0);
        lbv = lbv0 + f * (lbv1 - lbv0);
        return new Color(hue, sat, lbv, m);
      } else if (m === 'rgb') {
        xyz0 = me.rgb;
        xyz1 = col.rgb;
        return new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
      } else if (m === 'lab') {
        xyz0 = me.lab();
        xyz1 = col.lab();
        return new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
      } else {
        throw "color mode " + m + " is not supported";
      }
    };

    return Color;

  })();

  Color.hex2rgb = function(hex) {
    var b, g, r, u;
    if (!hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
      if ((chroma.colors != null) && chroma.colors[hex]) {
        hex = chroma.colors[hex];
      } else {
        throw "unknown color format: " + hex;
      }
    }
    if (hex.length === 4 || hex.length === 7) hex = hex.substr(1);
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    u = parseInt(hex, 16);
    r = u >> 16;
    g = u >> 8 & 0xFF;
    b = u & 0xFF;
    return [r, g, b];
  };

  Color.rgb2hex = function(r, g, b) {
    var str, u, _ref2;
    if (r !== void 0 && r.length === 3) {
      _ref2 = r, r = _ref2[0], g = _ref2[1], b = _ref2[2];
    }
    u = r << 16 | g << 8 | b;
    str = "000000" + u.toString(16).toUpperCase();
    return "#" + str.substr(str.length - 6);
  };

  Color.hsv2rgb = function(h, s, v) {
    var b, f, g, i, l, p, q, r, t, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    if (type(h) === "array" && h.length === 3) {
      _ref2 = h, h = _ref2[0], s = _ref2[1], l = _ref2[2];
    }
    v *= 255;
    if (s === 0 && isNaN(h)) {
      r = g = b = v;
    } else {
      if (h === 360) h = 0;
      if (h > 360) h -= 360;
      if (h < 0) h += 360;
      h /= 60;
      i = Math.floor(h);
      f = h - i;
      p = v * (1 - s);
      q = v * (1 - s * f);
      t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          _ref3 = [v, t, p], r = _ref3[0], g = _ref3[1], b = _ref3[2];
          break;
        case 1:
          _ref4 = [q, v, p], r = _ref4[0], g = _ref4[1], b = _ref4[2];
          break;
        case 2:
          _ref5 = [p, v, t], r = _ref5[0], g = _ref5[1], b = _ref5[2];
          break;
        case 3:
          _ref6 = [p, q, v], r = _ref6[0], g = _ref6[1], b = _ref6[2];
          break;
        case 4:
          _ref7 = [t, p, v], r = _ref7[0], g = _ref7[1], b = _ref7[2];
          break;
        case 5:
          _ref8 = [v, p, q], r = _ref8[0], g = _ref8[1], b = _ref8[2];
      }
    }
    r = Math.round(r);
    g = Math.round(g);
    b = Math.round(b);
    return [r, g, b];
  };

  Color.rgb2hsv = function(r, g, b) {
    var delta, h, max, min, s, v, _ref2;
    if (r !== void 0 && r.length === 3) {
      _ref2 = r, r = _ref2[0], g = _ref2[1], b = _ref2[2];
    }
    min = Math.min(r, g, b);
    max = Math.max(r, g, b);
    delta = max - min;
    v = max / 255.0;
    s = delta / max;
    if (s === 0) {
      h = void 0;
      s = 0;
    } else {
      if (r === max) h = (g - b) / delta;
      if (g === max) h = 2 + (b - r) / delta;
      if (b === max) h = 4 + (r - g) / delta;
      h *= 60;
      if (h < 0) h += 360;
    }
    return [h, s, v];
  };

  Color.hsl2rgb = function(h, s, l) {
    var b, c, g, i, r, t1, t2, t3, _ref2, _ref3;
    if (h !== void 0 && h.length === 3) {
      _ref2 = h, h = _ref2[0], s = _ref2[1], l = _ref2[2];
    }
    if (s === 0) {
      r = g = b = l * 255;
    } else {
      t3 = [0, 0, 0];
      c = [0, 0, 0];
      t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
      t1 = 2 * l - t2;
      h /= 360;
      t3[0] = h + 1 / 3;
      t3[1] = h;
      t3[2] = h - 1 / 3;
      for (i = 0; i <= 2; i++) {
        if (t3[i] < 0) t3[i] += 1;
        if (t3[i] > 1) t3[i] -= 1;
        if (6 * t3[i] < 1) {
          c[i] = t1 + (t2 - t1) * 6 * t3[i];
        } else if (2 * t3[i] < 1) {
          c[i] = t2;
        } else if (3 * t3[i] < 2) {
          c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6;
        } else {
          c[i] = t1;
        }
      }
      _ref3 = [Math.round(c[0] * 255), Math.round(c[1] * 255), Math.round(c[2] * 255)], r = _ref3[0], g = _ref3[1], b = _ref3[2];
    }
    return [r, g, b];
  };

  Color.rgb2hsl = function(r, g, b) {
    var h, l, max, min, s, _ref2;
    if (r !== void 0 && r.length === 3) {
      _ref2 = r, r = _ref2[0], g = _ref2[1], b = _ref2[2];
    }
    r /= 255;
    g /= 255;
    b /= 255;
    min = Math.min(r, g, b);
    max = Math.max(r, g, b);
    l = (max + min) / 2;
    if (max === min) {
      s = 0;
      h = void 0;
    } else {
      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
    }
    if (r === max) {
      h = (g - b) / (max - min);
    } else if (g === max) {
      h = 2 + (b - r) / (max - min);
    } else if (b === max) {
      h = 4 + (r - g) / (max - min);
    }
    h *= 60;
    if (h < 0) h += 360;
    return [h, s, l];
  };

  Color.lab2xyz = function(l, a, b) {
    /*
    	Convert from L*a*b* doubles to XYZ doubles
    	Formulas drawn from http://en.wikipedia.org/wiki/Lab_color_spaces
    */
    var finv, ill, sl, x, y, z, _ref2;
    if (type(l) === "array" && l.length === 3) {
      _ref2 = l, l = _ref2[0], a = _ref2[1], b = _ref2[2];
    }
    finv = function(t) {
      if (t > (6.0 / 29.0)) {
        return t * t * t;
      } else {
        return 3 * (6.0 / 29.0) * (6.0 / 29.0) * (t - 4.0 / 29.0);
      }
    };
    sl = (l + 0.16) / 1.16;
    ill = [0.96421, 1.00000, 0.82519];
    y = ill[1] * finv(sl);
    x = ill[0] * finv(sl + (a / 5.0));
    z = ill[2] * finv(sl - (b / 2.0));
    return [x, y, z];
  };

  Color.xyz2rgb = function(x, y, z) {
    /*
    	Convert from XYZ doubles to sRGB bytes
    	Formulas drawn from http://en.wikipedia.org/wiki/Srgb
    */
    var b, bl, clip, correct, g, gl, r, rl, _ref2, _ref3;
    if (type(x) === "array" && x.length === 3) {
      _ref2 = x, x = _ref2[0], y = _ref2[1], z = _ref2[2];
    }
    rl = 3.2406 * x - 1.5372 * y - 0.4986 * z;
    gl = -0.9689 * x + 1.8758 * y + 0.0415 * z;
    bl = 0.0557 * x - 0.2040 * y + 1.0570 * z;
    clip = Math.min(rl, gl, bl) < -0.001 || Math.max(rl, gl, bl) > 1.001;
    if (clip) {
      rl = rl < 0.0 ? 0.0 : rl > 1.0 ? 1.0 : rl;
      gl = gl < 0.0 ? 0.0 : gl > 1.0 ? 1.0 : gl;
      bl = bl < 0.0 ? 0.0 : bl > 1.0 ? 1.0 : bl;
    }
    if (clip) {
      _ref3 = [void 0, void 0, void 0], rl = _ref3[0], gl = _ref3[1], bl = _ref3[2];
    }
    correct = function(cl) {
      var a;
      a = 0.055;
      if (cl <= 0.0031308) {
        return 12.92 * cl;
      } else {
        return (1 + a) * Math.pow(cl, 1 / 2.4) - a;
      }
    };
    r = Math.round(255.0 * correct(rl));
    g = Math.round(255.0 * correct(gl));
    b = Math.round(255.0 * correct(bl));
    return [r, g, b];
  };

  Color.lab2rgb = function(l, a, b) {
    /*
    	Convert from LAB doubles to sRGB bytes 
    	(just composing the above transforms)
    */
    var x, y, z, _ref2, _ref3, _ref4;
    if (l !== void 0 && l.length === 3) {
      _ref2 = l, l = _ref2[0], a = _ref2[1], b = _ref2[2];
    }
    if (l !== void 0 && l.length === 3) {
      _ref3 = l, l = _ref3[0], a = _ref3[1], b = _ref3[2];
    }
    _ref4 = Color.lab2xyz(l, a, b), x = _ref4[0], y = _ref4[1], z = _ref4[2];
    return Color.xyz2rgb(x, y, z);
  };

  Color.csl2lab = function(c, s, l) {
    /*
    	Convert from a qualitative parameter c and a quantitative parameter l to a 24-bit pixel. These formulas were invented by David Dalrymple to obtain maximum contrast without going out of gamut if the parameters are in the range 0-1.
    	
    	A saturation multiplier was added by Gregor Aisch
    */
    var L, TAU, a, angle, b, r, _ref2;
    if (type(c) === "array" && c.length === 3) {
      _ref2 = c, c = _ref2[0], s = _ref2[1], l = _ref2[2];
    }
    c /= 360.0;
    TAU = 6.283185307179586476925287;
    L = l * 0.61 + 0.09;
    angle = TAU / 6.0 - c * TAU;
    r = (l * 0.311 + 0.125) * s;
    a = Math.sin(angle) * r;
    b = Math.cos(angle) * r;
    return [L, a, b];
  };

  Color.csl2rgb = function(c, s, l) {
    var L, a, b, _ref2;
    _ref2 = Color.csl2lab(c, s, l), L = _ref2[0], a = _ref2[1], b = _ref2[2];
    return Color.lab2rgb(L, a, b);
  };

  Color.rgb2xyz = function(r, g, b) {
    var bl, correct, gl, rl, x, y, z, _ref2;
    if (r !== void 0 && r.length === 3) {
      _ref2 = r, r = _ref2[0], g = _ref2[1], b = _ref2[2];
    }
    correct = function(c) {
      var a;
      a = 0.055;
      if (c <= 0.04045) {
        return c / 12.92;
      } else {
        return Math.pow((c + a) / (1 + a), 2.4);
      }
    };
    rl = correct(r / 255.0);
    gl = correct(g / 255.0);
    bl = correct(b / 255.0);
    x = 0.4124 * rl + 0.3576 * gl + 0.1805 * bl;
    y = 0.2126 * rl + 0.7152 * gl + 0.0722 * bl;
    z = 0.0193 * rl + 0.1192 * gl + 0.9505 * bl;
    return [x, y, z];
  };

  Color.xyz2lab = function(x, y, z) {
    var a, b, f, ill, l, _ref2;
    if (x !== void 0 && x.length === 3) {
      _ref2 = x, x = _ref2[0], y = _ref2[1], z = _ref2[2];
    }
    ill = [0.96421, 1.00000, 0.82519];
    f = function(t) {
      if (t > Math.pow(6.0 / 29.0, 3)) {
        return Math.pow(t, 1 / 3);
      } else {
        return (1 / 3) * (29 / 6) * (29 / 6) * t + 4.0 / 29.0;
      }
    };
    l = 1.16 * f(y / ill[1]) - 0.16;
    a = 5 * (f(x / ill[0]) - f(y / ill[1]));
    b = 2 * (f(y / ill[1]) - f(z / ill[2]));
    return [l, a, b];
  };

  Color.rgb2lab = function(r, g, b) {
    var x, y, z, _ref2, _ref3;
    if (r !== void 0 && r.length === 3) {
      _ref2 = r, r = _ref2[0], g = _ref2[1], b = _ref2[2];
    }
    _ref3 = Color.rgb2xyz(r, g, b), x = _ref3[0], y = _ref3[1], z = _ref3[2];
    return Color.xyz2lab(x, y, z);
  };

  Color.lab2csl = function(l, a, b) {
    /*
    	Convert from a qualitative parameter c and a quantitative parameter l to a 24-bit pixel. These formulas were invented by David Dalrymple to obtain maximum contrast without going out of gamut if the parameters are in the range 0-1.
    	
    	A saturation multiplier was added by Gregor Aisch
    */
    var L, TAU, angle, c, r, s, _ref2;
    if (type(l) === "array" && l.length === 3) {
      _ref2 = l, l = _ref2[0], a = _ref2[1], b = _ref2[2];
    }
    L = l;
    l = (l - 0.09) / 0.61;
    r = Math.sqrt(a * a + b * b);
    s = r / (l * 0.311 + 0.125);
    TAU = 6.283185307179586476925287;
    angle = Math.atan2(a, b);
    c = (TAU / 6 - angle) / TAU;
    c *= 360;
    if (c < 0) c += 360;
    return [c, s, l];
  };

  Color.rgb2csl = function(r, g, b) {
    var a, l, _ref2, _ref3;
    if (type(r) === "array" && r.length === 3) {
      _ref2 = r, r = _ref2[0], g = _ref2[1], b = _ref2[2];
    }
    _ref3 = Color.rgb2lab(r, g, b), l = _ref3[0], a = _ref3[1], b = _ref3[2];
    return Color.lab2csl(l, a, b);
  };

  Color.rgb2hsi = function(r, g, b) {
    /*
    	borrowed from here:
    	http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
    */
    var TWOPI, h, i, min, s, _ref2;
    if (type(r) === "array" && r.length === 3) {
      _ref2 = r, r = _ref2[0], g = _ref2[1], b = _ref2[2];
    }
    TWOPI = Math.PI * 2;
    r /= 255;
    g /= 255;
    b /= 255;
    min = Math.min(r, g, b);
    i = (r + g + b) / 3;
    s = 1 - min / i;
    if (s === 0) {
      h = 0;
    } else {
      h = ((r - g) + (r - b)) / 2;
      h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));
      h = Math.acos(h);
      if (b > g) h = TWOPI - h;
      h /= TWOPI;
    }
    return [h * 360, s, i];
  };

  Color.hsi2rgb = function(h, s, i) {
    /*
    	borrowed from here:
    	http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
    */
    var PITHIRD, TWOPI, b, cos, g, r, _ref2;
    if (type(h) === "array" && h.length === 3) {
      _ref2 = h, h = _ref2[0], s = _ref2[1], i = _ref2[2];
    }
    TWOPI = Math.PI * 2;
    PITHIRD = Math.PI / 3;
    cos = Math.cos;
    if (h < 0) h += 360;
    if (h > 360) h -= 360;
    h /= 360;
    if (h < 1 / 3) {
      b = (1 - s) / 3;
      r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
      g = 1 - (b + r);
    } else if (h < 2 / 3) {
      h -= 1 / 3;
      r = (1 - s) / 3;
      g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
      b = 1 - (r + g);
    } else {
      h -= 2 / 3;
      g = (1 - s) / 3;
      b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
      r = 1 - (g + b);
    }
    r = i * r * 3;
    g = i * g * 3;
    b = i * b * 3;
    return [r * 255, g * 255, b * 255];
  };

  chroma.Color = Color;

  chroma.hsl = function(h, s, l) {
    return new Color(h, s, l, 'hsl');
  };

  chroma.hsv = function(h, s, v) {
    return new Color(h, s, v, 'hsv');
  };

  chroma.rgb = function(r, g, b) {
    return new Color(r, g, b, 'rgb');
  };

  chroma.hex = function(x) {
    return new Color(x);
  };

  chroma.lab = function(l, a, b) {
    return new Color(l, a, b, 'lab');
  };

  chroma.csl = function(c, s, l) {
    return new Color(c, s, l, 'csl');
  };

  chroma.hsi = function(h, s, i) {
    return new Color(h, s, i, 'hsi');
  };

  chroma.interpolate = function(a, b, f, m) {
    if (type(a) === 'string') a = new Color(a);
    if (type(b) === 'string') b = new Color(b);
    return a.interpolate(f, b, m);
  };

  ColorScale = (function() {

    /*
    	base class for color scales
    */

    function ColorScale(opts) {
      var c, col, cols, me, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      me = this;
      me.colors = cols = (_ref2 = opts.colors) != null ? _ref2 : ['#ddd', '#222'];
      for (c = 0, _ref3 = cols.length - 1; 0 <= _ref3 ? c <= _ref3 : c >= _ref3; 0 <= _ref3 ? c++ : c--) {
        col = cols[c];
        if (type(col) === "string") cols[c] = new Color(col);
      }
      if (opts.positions != null) {
        me.pos = opts.positions;
      } else {
        me.pos = [];
        for (c = 0, _ref4 = cols.length - 1; 0 <= _ref4 ? c <= _ref4 : c >= _ref4; 0 <= _ref4 ? c++ : c--) {
          me.pos.push(c / (cols.length - 1));
        }
      }
      me.mode = (_ref5 = opts.mode) != null ? _ref5 : 'hsv';
      me.nacol = (_ref6 = opts.nacol) != null ? _ref6 : '#ccc';
      me.setClasses((_ref7 = opts.limits) != null ? _ref7 : [0, 1]);
      me;
    }

    ColorScale.prototype.getColor = function(value) {
      var c, f, f0, me;
      me = this;
      if (isNaN(value)) return me.nacol;
      if (me.classLimits.length > 2) {
        c = me.getClass(value);
        f = c / (me.numClasses - 1);
      } else {
        f = f0 = (value - me.min) / (me.max - me.min);
        f = Math.min(1, Math.max(0, f));
      }
      return me.fColor(f);
    };

    ColorScale.prototype.fColor = function(f) {
      var col, cols, i, me, p, _ref2;
      me = this;
      cols = me.colors;
      for (i = 0, _ref2 = me.pos.length - 1; 0 <= _ref2 ? i <= _ref2 : i >= _ref2; 0 <= _ref2 ? i++ : i--) {
        p = me.pos[i];
        if (f <= p) {
          col = cols[i];
          break;
        }
        if (f >= p && i === me.pos.length - 1) {
          col = cols[i];
          break;
        }
        if (f > p && f < me.pos[i + 1]) {
          f = (f - p) / (me.pos[i + 1] - p);
          col = chroma.interpolate(cols[i], cols[i + 1], f, me.mode);
          break;
        }
      }
      return col;
    };

    ColorScale.prototype.classifyValue = function(value) {
      var i, limits, maxc, minc, n, self;
      self = this;
      limits = self.classLimits;
      if (limits.length > 2) {
        n = limits.length - 1;
        i = self.getClass(value);
        value = limits[i] + (limits[i + 1] - limits[i]) * 0.5;
        minc = limits[0];
        maxc = limits[n - 1];
        value = self.min + ((value - minc) / (maxc - minc)) * (self.max - self.min);
      }
      return value;
    };

    ColorScale.prototype.setClasses = function(limits) {
      var me;
      if (limits == null) limits = [];
      /*
      		# use this if you want to display a limited number of data classes
      		# possible methods are "equalinterval", "quantiles", "custom"
      */
      me = this;
      me.classLimits = limits;
      me.min = limits[0];
      me.max = limits[limits.length - 1];
      if (limits.length === 2) {
        return me.numClasses = 0;
      } else {
        return me.numClasses = limits.length - 1;
      }
    };

    ColorScale.prototype.getClass = function(value) {
      var i, limits, n, self;
      self = this;
      limits = self.classLimits;
      if (limits != null) {
        n = limits.length - 1;
        i = 0;
        while (i < n && value >= limits[i]) {
          i++;
        }
        return i - 1;
      }
    };

    ColorScale.prototype.validValue = function(value) {
      return !isNaN(value);
    };

    return ColorScale;

  })();

  chroma.ColorScale = ColorScale;

  Ramp = (function() {

    __extends(Ramp, ColorScale);

    function Ramp(col0, col1, mode) {
      if (col0 == null) col0 = '#fe0000';
      if (col1 == null) col1 = '#feeeee';
      if (mode == null) mode = 'hsl';
      Ramp.__super__.constructor.call(this, [col0, col1], [0, 1], mode);
    }

    return Ramp;

  })();

  chroma.Ramp = Ramp;

  Diverging = (function() {

    __extends(Diverging, ColorScale);

    function Diverging(col0, col1, col2, center, mode) {
      var me;
      if (col0 == null) col0 = '#d73027';
      if (col1 == null) col1 = '#ffffbf';
      if (col2 == null) col2 = '#1E6189';
      if (center == null) center = 'mean';
      if (mode == null) mode = 'hsl';
      me = this;
      me.mode = mode;
      me.center = center;
      Diverging.__super__.constructor.call(this, [col0, col1, col2], [0, .5, 1], mode);
    }

    Diverging.prototype.parseData = function(data, data_col) {
      var c, me;
      Diverging.__super__.parseData.call(this, data, data_col);
      me = this;
      c = me.center;
      if (c === 'median') {
        c = me.median;
      } else if (c === 'mean') {
        c = me.mean;
      }
      return me.pos[1] = (c - me.min) / (me.max - me.min);
    };

    return Diverging;

  })();

  chroma.Diverging = Diverging;

  Categories = (function() {

    __extends(Categories, ColorScale);

    function Categories(colors) {
      var me;
      me = this;
      me.colors = colors;
    }

    Categories.prototype.parseData = function(data, data_col) {};

    Categories.prototype.getColor = function(value) {
      var me;
      me = this;
      if (me.colors.hasOwnProperty(value)) {
        return me.colors[value];
      } else {
        return '#cccccc';
      }
    };

    Categories.prototype.validValue = function(value) {
      return this.colors.hasOwnProperty(value);
    };

    return Categories;

  })();

  chroma.Categories = Categories;

  CSSColors = (function() {

    __extends(CSSColors, ColorScale);

    function CSSColors(name) {
      var me;
      me = this;
      me.name = name;
      me.setClasses(7);
      me;
    }

    CSSColors.prototype.getColor = function(value) {
      var c, me;
      me = this;
      c = me.getClass(value);
      return me.name + ' l' + me.numClasses + ' c' + c;
    };

    return CSSColors;

  })();

  chroma.CSSColors = CSSColors;

  if ((_ref2 = chroma.scales) == null) chroma.scales = {};

  chroma.scales.cool = function() {
    return new Ramp(chroma.hsl(180, 1, .9), chroma.hsl(250, .7, .4));
  };

  chroma.scales.hot = function() {
    return new ColorScale({
      colors: ['#000000', '#ff0000', '#ffff00', '#ffffff'],
      positions: [0, .25, .75, 1],
      mode: 'rgb'
    });
  };

  chroma.scales.BlWhOr = function() {
    return new Diverging(chroma.hsl(30, 1, .55), '#ffffff', new Color(220, 1, .55));
  };

  chroma.scales.GrWhPu = function() {
    return new Diverging(chroma.hsl(120, .8, .4), '#ffffff', new Color(280, .8, .4));
  };

  chroma.limits = function(data, mode, num, prop) {
    var assignments, best, centroids, cluster, clusterSizes, dist, i, j, k, kClusters, limits, max, min, mindist, n, nb_iters, newCentroids, p, pb, pr, repeat, sum, tmpKMeansBreaks, val, value, values, _i, _j, _len, _len2, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (mode == null) mode = 'equal';
    if (num == null) num = 7;
    if (prop == null) prop = null;
    min = Number.MAX_VALUE;
    max = Number.MAX_VALUE * -1;
    sum = 0;
    values = [];
    if (type(data) === "array") {
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        val = data[_i];
        if (!isNaN(val)) values.push(val);
      }
    } else if (type(data) === "object") {
      for (k in data) {
        val = data[k];
        if (type(val) === "object" && type(prop) === "string") {
          if (!isNaN(val[prop])) values.push(val[prop]);
        } else if (type(val) === "number") {
          if (!isNaN(val)) values.push(val);
        }
      }
    }
    for (_j = 0, _len2 = values.length; _j < _len2; _j++) {
      val = values[_j];
      if (!!isNaN(val)) continue;
      if (val < min) min = val;
      if (val > max) max = val;
      sum += val;
    }
    values = values.sort();
    limits = [];
    if (mode.substr(0, 1) === 'c') {
      limits.push(min);
      limits.push(max);
    }
    if (mode.substr(0, 1) === 'e') {
      limits.push(min);
      for (i = 1, _ref3 = num - 1; 1 <= _ref3 ? i <= _ref3 : i >= _ref3; 1 <= _ref3 ? i++ : i--) {
        limits.push(min + (i / num) * (max - min));
      }
      limits.push(max);
    } else if (mode.substr(0, 1) === 'q') {
      limits.push(min);
      for (i = 1, _ref4 = num - 1; 1 <= _ref4 ? i <= _ref4 : i >= _ref4; 1 <= _ref4 ? i++ : i--) {
        p = values.length * i / num;
        pb = Math.floor(p);
        if (pb === p) {
          limits.push(values[pb]);
        } else {
          pr = p - pb;
          limits.push(values[pb] * pr + values[pb + 1] * (1 - pr));
        }
      }
      limits.push(max);
    } else if (mode.substr(0, 1) === 'k') {
      /*
      		implementation based on
      		http://code.google.com/p/figue/source/browse/trunk/figue.js#336
      		simplified for 1-d input values
      */
      n = values.length;
      assignments = new Array(n);
      clusterSizes = new Array(num);
      repeat = true;
      nb_iters = 0;
      centroids = null;
      centroids = [];
      centroids.push(min);
      for (i = 1, _ref5 = num - 1; 1 <= _ref5 ? i <= _ref5 : i >= _ref5; 1 <= _ref5 ? i++ : i--) {
        centroids.push(min + (i / num) * (max - min));
      }
      centroids.push(max);
      while (repeat) {
        for (j = 0, _ref6 = num - 1; 0 <= _ref6 ? j <= _ref6 : j >= _ref6; 0 <= _ref6 ? j++ : j--) {
          clusterSizes[j] = 0;
        }
        for (i = 0, _ref7 = n - 1; 0 <= _ref7 ? i <= _ref7 : i >= _ref7; 0 <= _ref7 ? i++ : i--) {
          value = values[i];
          mindist = Number.MAX_VALUE;
          for (j = 0, _ref8 = num - 1; 0 <= _ref8 ? j <= _ref8 : j >= _ref8; 0 <= _ref8 ? j++ : j--) {
            dist = Math.abs(centroids[j] - value);
            if (dist < mindist) {
              mindist = dist;
              best = j;
            }
          }
          clusterSizes[best]++;
          assignments[i] = best;
        }
        newCentroids = new Array(num);
        for (j = 0, _ref9 = num - 1; 0 <= _ref9 ? j <= _ref9 : j >= _ref9; 0 <= _ref9 ? j++ : j--) {
          newCentroids[j] = null;
        }
        for (i = 0, _ref10 = n - 1; 0 <= _ref10 ? i <= _ref10 : i >= _ref10; 0 <= _ref10 ? i++ : i--) {
          cluster = assignments[i];
          if (newCentroids[cluster] === null) {
            newCentroids[cluster] = values[i];
          } else {
            newCentroids[cluster] += values[i];
          }
        }
        for (j = 0, _ref11 = num - 1; 0 <= _ref11 ? j <= _ref11 : j >= _ref11; 0 <= _ref11 ? j++ : j--) {
          newCentroids[j] *= 1 / clusterSizes[j];
        }
        repeat = false;
        for (j = 0, _ref12 = num - 1; 0 <= _ref12 ? j <= _ref12 : j >= _ref12; 0 <= _ref12 ? j++ : j--) {
          if (newCentroids[j] !== centroids[i]) {
            repeat = true;
            break;
          }
        }
        centroids = newCentroids;
        nb_iters++;
        if (nb_iters > 200) repeat = false;
      }
      kClusters = {};
      for (j = 0, _ref13 = num - 1; 0 <= _ref13 ? j <= _ref13 : j >= _ref13; 0 <= _ref13 ? j++ : j--) {
        kClusters[j] = [];
      }
      for (i = 0, _ref14 = n - 1; 0 <= _ref14 ? i <= _ref14 : i >= _ref14; 0 <= _ref14 ? i++ : i--) {
        cluster = assignments[i];
        kClusters[cluster].push(values[i]);
      }
      tmpKMeansBreaks = [];
      for (j = 0, _ref15 = num - 1; 0 <= _ref15 ? j <= _ref15 : j >= _ref15; 0 <= _ref15 ? j++ : j--) {
        tmpKMeansBreaks.push(kClusters[j][0]);
        tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);
      }
      tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {
        return a - b;
      });
      limits.push(tmpKMeansBreaks[0]);
      for (i = 1, _ref16 = tmpKMeansBreaks.length - 1; i <= _ref16; i += 2) {
        if (!isNaN(tmpKMeansBreaks[i])) limits.push(tmpKMeansBreaks[i]);
      }
    }
    return limits;
  };

  /*
  utils.coffee
  */

  type = (function() {
    /*
    	for browser-safe type checking+
    	ported from jQuery's $.type
    */
    var classToType, name, _i, _len, _ref3;
    classToType = {};
    _ref3 = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      name = _ref3[_i];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    return function(obj) {
      var strType;
      strType = Object.prototype.toString.call(obj);
      return classToType[strType] || "object";
    };
  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.type = type;

  Array.max = function(array) {
    return Math.max.apply(Math, array);
  };

  Array.min = function(array) {
    return Math.min.apply(Math, array);
  };

}).call(this);
